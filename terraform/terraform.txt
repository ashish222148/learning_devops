Chapter-1
Terraform(IAAC) has two edition:
1-community edition (free and open source)
2-enterprise edition (paid)
registry.terraform.io
scope:identify resource where you want to write the data.scope can be multiple (like aws, azure, gcp etc)
author:write code/ terraform configuration
initialize: local file will be downloaded
plan:get the result what is goint to happen before deploy
apply: make the changes.

plaform have multiple interface:
	CLI:
	GUI:
	when program wants to connect to your application, then we need a account which is known as service account.
	for authetication to any application we need service account.
	application has own interface which is known as api
	user interface : cli and gui, these are interactive, we give the input on demand
	application interface : api for example git hub rest api endpoint, its non iteractive
	curl https://qoogle.com -- vvv
	vvv: verbocity mode has been increased.
	chere will be get command bydefault being used.
	plugins/provider (just like dictionary): when we run init , it downloads plugins, because how the terraform will undertand the language of target (aws/azure/gcp) .
	terraform download provider from the registry, i.e. registry. terraform.io
Note: there should be api on target and second thing provider should be there.
	provider have three category:
		1-official (managed by hasicorp)
		2-partner (managed by provider it self)
		3-community
	there are versions of provider as well.
	priovider written in go langualge even terraform written in go language.
Exam Ques: does terraform need go language required to run terraform ? NO
	key value language: json and yml and xml

json : no indentation required
yml: indentaion required
terraform -- version
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Chapter-2:
main.tf: file name could be any , only extension should be .tf
	a-terraform init-download provider, initialize backend, download module. this is one time activity unless you change terraform block.backend is location where terraform keeps its state file, if you not mention
					the location, its keep the same in the current directory.
					when we run the terraform init, it initialize the backend, initializing provider plugins and terraform create a hcl file(terraform. lock.hcl) to record the provider selection it made made above.
					Include this file in your version control system (vcs) like github, so that terraform can gurantee to make the same selection by default when you run the "terraform init" in future.
					terraform download providers and downloads in .terraform folder (hidden file)

	b-terraform plan-checks the config drift and present the summary of what changes are going to be provisioned.
	c-terraform apply-apply the changes presented in your plan i.e provision infrastructure

	all above these command , will read all the .tf files in the directory and aggregate them and then work on it, it is alos known as terraform configuration file.
	code: Written in HCL
	
	blocks:
	1-terraform : how many providers are required to this terraform to accomplish the task and those provider will be downloaded from this place., we can also mention the url here.
	2-providers : aws configuration option for example region.
	3-resource
	4-variable
	6-output
	7-module
	8-local

main.tf:
************single provider:

#####################################################################################terraform block

terraform {
	required providers {
		aws {
			source = "hashicorp/aws"
			version - "6.0.0-betal"
		}
	}
}
#####################################################################################provider block
provider "aws" (
	#Configuration options
	region = "ap-south-1"
}
*****************************


*********multiple provider:
terraform {
	required providers {
		aws {
			source = "hashicorp/aws"
			version - "6.0.0-betal"
		}
		azurerm {
		source = "hashicorp/azurerm
		version = "4.28.0"
		}
	}
}

provider "aws"{
	# Configuration options
	region = "ap-south-1"
}
porovider "azurerm" {
# Configuration options
}
******************************

authentication with aws:
	The machine from where we are running the terraform, authentication required from that machine to aws, in case of jenkins, authentication will be at jenkins machine where terraform is running.
		1-not recommanded: in provider section , you can mention the same . but the problem is when you push the terraform code in git, it will be blocked.
			provider "aws" {
				#Configuration options
				region - "ap-south-1"
				access_key-""
				secret key=""

		2-Environment variable:recommanded method while using CICD.
			export AWS_ACCESS_KEY_ID=""
			export AWS_SECRET_ACCESS KEY-"
			
		3-download cli and configure
			aws configure -- profile-profilel
			export AWS DEFAULT PROFILE-profile1

##################################################################################resource block:

terraform {
	required providers {
		aws {
			source = "hashicorp/aws"
			version - "6.0.0-betal"
		}
	}
}
provider "aws" (
	#Configuration options
	region = "ap-south-1"
}

resource "aws vpc" "ailiya"(
	cidr block = ""
	tags = {
		name = "main"
		}
}

#note:any provider documentation only two block we will get, reources and data


Q:how to delete reource?
	original command
	terraform apply -- destroy
	alias
	terraform destroy

Note: If you want to delete a single resource, just comment it in configuration file and just fire command terraform apply.

What is state file:
    when we run command terraform apply, same will be excuted on cloud end and a copy of information of that resource(resource id) is going to be
    stored on state file.
    and next time when we run apply, it is going to check first in the statefile whether we have those information or not
    then it reads on the cloud end, whether same resource is available on clould or not.
    state file is written in json format.
	

If we manually do any modition in aws resource, then terraform is going to revert back the same because for terraform only source of truth is main.tf file.

resource name should be always diffrent.

terraform validate: this command will check the error if we will have in conguration file.
terraform apply -auto approve
	
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
chapter-3

reource id shold be unique.

when we run plan terraform plan, it first check the main.tf file then it goes in state file and check the resource just like aws_vpc.ailiya, if same is found in state file, it will refresh the satate file and fetch
the id, once id will be there it will go in aws and check the resource id, if same exist with the given value in statefile , it will not do any thing , else it will create or chage the resource in aws.

statefile keeps the recored of aws resource block.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
chapter-4

in cicd , we will use environment varibale menthod for authenticatio.

version contraints:
	semantic versioning:
    1.0.0
    major.minor.patch
    major: incapitable api changes
    minor: added functionality,backward compatibility
    patch: incremented, backward compatibility, bugfixes
	
	in pipe line every time we do init , pipeline launches on diffrent lachine
	
version constraints:
    version = ">= 1.2.0, < 2.0.0" --> this is best option
    The following operators are valid:
        = (or no operator): Allows only one exact version number. Cannot be combined with other conditions.
        !=: Excludes an exact version number.
        >, >=, <, <=: Comparisons against a specified version, allowing versions for which the comparison is true. "Greater-than" requests newer versions, and "less-than" requests older versions.
        ~>: Allows only the rightmost version component to increment. For example, to allow new patch releases within a specific minor release, use the full version number: ~> 1.0.4 will allow installation of 1.0.5 and 
		1.0.10 but not 1.1.0. This is usually called the pessimistic constraint operator.
		
		if provider already exist, so to download, user command
			~>5.60.0
			terraform init --upgrade
		terraform inint -upgrade, it will upgrade the provider , keeps both version which is installed previosly and the latest one as you mentioned in the command.
		
		
commenting:
    single line comment: //
    multiline comment: /*
                        */


suppose we do any manual change in aws, terraform will read the configuration file then it will check the same in state file, if resource is found, it will refresh the id, after getting the resource id, it will fetch the resouce id 
details through api and match the details from the configuraion file and changes accordingly.

provider Alias:
	if you want to create a resource not in given default region, but some resource you can create on diffrent region. then alias comes in to picture.
	
	provider block support only one region but we can't mention duplicate block, so we mention alias.
	
terraform {
	required providers {
		aws {
			source = "hashicorp/aws"
			version - "6.0.0-betal"
		}
	}
}
provider "aws" (
	#Configuration options
	region = "ap-south-1"
}

provider "aws" {
	region = "us-east-1"
	alias = "dev"
	}

resource "aws vpc" "ailiya"(
	cidr block = ""
	tags = {
		name = "main"
		}
}
resource "aws vpc" "ailiya1"(
	cidr block = ""
	tags = {
		name = "main"
		}
	provider =aws.dev
}
	
#####################################################################################################################variable block

variable will be define such as var.variable name .

variable declaration will be from declaration block. for every variable , there should be seperate declaration block.
in every variable declation block, we have to mention data type, else it will be considered as string by default. for example:

terraform {
	required providers {
		aws {
			source = "hashicorp/aws"
			version - "6.0.0-betal"
		}
	}
}

variable "region" {
	type = string
}

variable "cidr" {
	type = string
}


provider "aws" (
	#Configuration options
	region = var.region_name
}

resource "aws vpc" "ailiya"(
	cidr_block = var.cidr

}



Now the Question is , how we will provide the value of variable?

variable Passing:
	1-by argument
		-var=<variable>=<value>
	example:
		terraform plan -var region="ap-south-1" -var cidr="192.168.1.2"
	
	2-by file:
		Explicitly providing file name in command prompt
			a-file with any name
				for example, ashish
				and mention the variable 
					region = "ap-south-1"
					cidr = 192.168.0.3/24
			then pass file name
			example:
				terraform plan -var-file=ashish
			Note: this is not recommended
		
		By default read file name from the same location
			b-terraform read file name in two forms:
				terraform.tfvars: give the exact file name
				no need to pass variable name explicitly
				for example:
					terraform plan
			c-keep any file name but extension will be auto.tfvars
				for example:
					ashish.auto.tfvars
	if you want to mention the by default variable , so define the same in variable block such as :
		variable "cidr" {
		type = string
		default="192.168.1.0/24"
		}
		

			